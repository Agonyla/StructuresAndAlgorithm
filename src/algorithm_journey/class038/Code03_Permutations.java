package algorithm_journey.class038;

/**
 * @author: Agony
 * @create: 2024/6/30 21:45
 * @describe:
 * @link:
 */
public class Code03_Permutations {


    // todo

    // 没有重复项数字的全排列
    // 思路
    // 设计一个函数 f(int[] num, int index)
    // num -> 提供的数组
    // index -> 数组的下标
    // 来到 i 位置
    // i 位置数与自己交换，调用递归
    // i 位置数与 i+1 交换，调用递归
    // i 位置数与 i+2 交换，调用递归
    // 。。。
    // i 位置数与 num.length - 1 交换，调用递归
    // 注意！！！ 交换玩之后还要换回来
    // 保证换之前的数组状态

    // 为什么要先和自己交换呢？
    // 因为当 i 来到 最终位置之后是要收集的
    // 如果不和自己交换，那么数组的初始顺序是收集不到的
    // 如 [1, 2] 要实现全排列
    // 如果 1 直接 2 交换，那么 1 直接和 2 交换然后收集就只有 [2,1] 这一项
    // 如 [1,2,3] 要是西安全排列
    // 如果不和自己交换的话，那么就收集不到 [1,2,3,] 和 [1,3,2] 两项了
    // 时间复杂度: o(n! * n)

    // 画一下递归调用图！！！
}
