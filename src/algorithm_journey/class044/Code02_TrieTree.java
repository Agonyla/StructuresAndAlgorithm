package algorithm_journey.class044;

/**
 * @author: Agony
 * @create: 2024/7/10 10:05
 * @describe:
 * @link:
 */
public class Code02_TrieTree {

    // todo

    // 静态数组实现前缀树

    // 全局变量
    // int[][] tree -> 二维数组存放节点
    // int[] pass -> pass[i]表示经过节点i的单词数量
    // int[] end -> end[i]表示以节点i为结束的单词数量
    // int cnt -> 当前已使用的最大节点编号，初始化为 1


    // tree数组的结构解释
    //
    // 第一维：代表前缀树中的节点。每个节点用一个整数索引表示，这个索引在代码中通过cnt变量动态分配。
    // 第二维：代表26个英文小写字母（‘a’ 到 ‘z’）。数组的这一部分用于指向当前节点的子节点。
    //
    // 工作原理
    //
    // 每个节点可以视为一个数组，这个数组有26个可能的位置，每个位置对应一个英文字母。
    // 例如，tree[1][0]存储的是从根节点（假设为1）到子节点的链接，这个子节点通过字符’a’（‘a’ - ‘a’ = 0）到达。
    // 如果tree[1][0]的值为0，说明不存在通过字符’a’的子节点；
    // 如果它有一个非零值，比如5，那就意味着存在一个通过字符’a’到达的子节点，这个节点在前缀树中的索引为5。
    //
    // 举个例子
    //
    // 假设你要在前缀树中插入单词”cat”：
    // 	1.	从根节点开始（通常索引为1）。
    // 	2.	查找字符’c’对应的子节点，计算索引：‘c’ - ‘a’ = 2。
    // 	3.	如果tree[1][2]为0，说明还没有任何单词通过这个路径，那么你需要创建一个新的节点（假设为节点2），并设置tree[1][2] = 2。
    // 	4.	接着，移动到节点2，重复这个过程，直到单词的所有字符都被处理。
    
}
