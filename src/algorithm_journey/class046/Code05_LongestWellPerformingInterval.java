package algorithm_journey.class046;

/**
 * @author: Agony
 * @create: 2024/7/17 09:50
 * @describe:
 * @link:
 */
public class Code05_LongestWellPerformingInterval {


    // todo

    // 表现良好的最长时间段

    // 思路
    // 和题目2类似
    // 把大于8的转化成1，小于等于8的转化成-1
    // 求累加和>=1的最长子数组长度
    // 特殊情况：
    // 1.如果0～i的累加和>=1时，直接返回i+1 不需要再转化成前缀和了
    // 2.如果0～i的累加和为sum<0，那么就找前缀和为sum-1最早出现的位置j，返回i-j
    // 如：0～i的累加和为-3
    // 那么就找前缀和为-4最早出现的位置
    // 因为转化后的数组值都是1，-1
    // 前缀和是一点一点变化的
    // 如果出现前缀和为-5，那么在其前必有前缀和为-4的位置
}
