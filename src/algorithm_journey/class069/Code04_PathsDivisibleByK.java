package algorithm_journey.class069;

/**
 * @author: Agony
 * @create: 2024/9/11 11:12
 * @describe:
 * @link:
 */
public class Code04_PathsDivisibleByK {

    // todo

    // 矩阵中和能被 K 整除的路径
    //
    // 暴力递归
    // 设计 int[] f1(int[][] grid, int m, int n, int k, int i, int j, int r)
    // -> 返回从(i,j)位置出发到(m-1,n-1)有多少路径，累积和%k的余数是r
    // grid -> 题目提供的网格
    // m -> m行
    // n -> n列
    // k -> 要求被k整除
    // i -> 从i行出发
    // j -> 从j列出发
    // r -> 剩下的余数
    // 边界条件：
    // i==m-1 && j==n-1 -> return grid[i][j]%k==r?1:0
    // 剩下的余数：
    // 如果要求 k=7，r=3
    // 当前数余2，那么剩下的余数为1
    // 当前书余4，那么剩下的余数为6
    // -> 剩下的余数 = (k+r - 当前余数) % k   (类似的之前同余原理有提到过)
    // 可能性分析：
    // 1️⃣如果能往下走 i+1<m -> 调用f
    // 2️⃣如果能往右走 j+1<n -> 调用f
    // 两种可能性相加
    //
    // 记忆化搜索
    // ...
    //
    // 动态规划 品一下❕❕❕
    // 设计 int[][][] dp = new int[m][n][k];
    // 这次不要把它想象成三维坐标
    // 把它想象成二维坐标，每一个位置里是一个一维数组
    // 如来到 (i,j) 位置，里面是一个一维数组: [0...k-1]   (如k=7，那么余数就只有0～6，所以一维数组s[3]就表示余数为3复合要求的路径和)
    // 位置依赖：
    // 这样从递归中就可以看到来到(i,j)位置都依赖其右边和下边的位置
    // 填报顺序：
    // 从下往上，从右往左
    // 特殊位置分析：
    // 右下角位置：dp[m-1][n-1][grid[m-1][n-1]%k]=1，表格中右下角位置的数能整除k就说明该位置是答案，有一条路径
    // 最后一行：(k+r - 后一列%k)%k
    // 最后一列：(k+r - 后一行%k)%k
}
