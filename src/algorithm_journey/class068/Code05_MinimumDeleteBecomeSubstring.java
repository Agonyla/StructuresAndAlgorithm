package algorithm_journey.class068;

/**
 * @author: Agony
 * @create: 2024/9/7 10:45
 * @describe:
 * @link:
 */
public class Code05_MinimumDeleteBecomeSubstring {


    // todo

    // 删除至少几个字符可以变成另一个字符串的子串
    //
    // 暴力递归：对数器验证，自己想
    //
    // 动态规划
    // 设计 int[][] dp = new int[][]
    // dp[i][j] 表示 s1前i个字符串，需要删除多少字符才能变成 s2 前j个字符组成字符串的任意后缀串(以最后一个字符结尾作为的子串)
    // 返回最后一行的最小值
    // 情况分析：
    // 1. s1[i-1]!=s2[j-1]
    // -> dp[i][j] = dp[i-1][j] + 1 (s1[0...i-2] 变成 s2[0...j-1] 要删除几个)
    // 2. s1[i-1]==s2[j-1]
    // -> dp[i][j] = dp[i-1][j-1] (该字符保留，s1[0...i-2] 变成 s2[0...j-2] 要删除几个)
    // 位置依赖：
    // 依赖左上和上边
    // 填表顺序：
    // 从左往右，从上往下
    // 特殊位置分析：
    // 第0行，s1="", -> 不需要删除，就是s2的后缀川，dp[0][j] = 0
    // 第0列，s2="", -> s1有几个字符需要删除几个才能变成空串，dp[i][0]=i
    // 最后返回最后一行的最小值

}
