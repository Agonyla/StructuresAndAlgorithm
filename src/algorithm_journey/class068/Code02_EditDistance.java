package algorithm_journey.class068;

/**
 * @author: Agony
 * @create: 2024/9/5 15:03
 * @describe:
 * @link:
 */
public class Code02_EditDistance {

    // todo
    //
    // 编辑距离
    //
    // 暴力递归 (试一下)❕❕❕
    //
    // 动态规划
    // 设计 int[][] dp = new int[][]
    // dp[i][j] 表示 s1[0...i-1] 前i个组成的前缀串 彻底变成s2[0...j-1]个取前j个字符串 所需要的最小代价
    // 可能性分析：
    // 1. s1[i-1]参与
    // 1.1 s1[i-1]参与，变成s2[j-1]
    // 1.1.1 s1[i-1]==s2[j-1]
    // -> 不需要任何代价，直接就是dp[i-1][j-1] (s1[0...i-2] 变成 s2[0...i-2])
    // 1.1.3 s1[i-1]!=s2[j-1]
    // -> dp[i-1][j-1] + 替换代价
    // 1.2 s1[i-1]参与，通过让s1[0...i-1]变成s2[0...j-2]，然后再插入s2[j-1]
    // -> dp[i][j-1] + 插入代价
    // 2. s1[i-1]不参与
    // 让s1[0...i-2]变成s2[0...j-1]，然后删除s1[i-1]
    // -> dp[i-1][j] + 删除代价
    // 可能性分析优化
    // 从上述几种可能性中，显然1.1.1 可能是是最好的，
    // 所以当s1[i-1]==s2[j-1]时，就直接调用
    // s1[i-1]!=s2[j-1]时，再去考虑另外的情况
    // 直接用if-else分成两大类
    // 依赖分析：
    // 来到(i,j)依赖于 (i-1, j-1) (i, j-1) (i-1, j), 依赖左边、上边和左上的值
    // 填表顺序：
    // 从左往右，从上往下
    // 特殊位置分析：
    // 第0行，s1一个字符都没有 -> 每一列都是插入代价，每一列的插入代价 = s2的字符个数 * 插入代价
    // 第0列，s2一个字符都没有 -> 每一行都是删除代价，每一行的删除代价 = s1的字符个数 * 删除代价
    //
    // 动态规划 + 空间压缩
    // 一维代替二维
    // 类似于上一节的Code03_LongestCommonSubsequence
    // 涉及到依赖三个位置，在使用空间压缩的时候，可以考虑是不是需要额外引入一个（实际是两个）变量来实现
}
