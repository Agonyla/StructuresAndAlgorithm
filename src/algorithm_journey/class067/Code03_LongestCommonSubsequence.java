package algorithm_journey.class067;

/**
 * @author: Agony
 * @create: 2024/9/1 14:55
 * @describe:
 * @link:
 */
public class Code03_LongestCommonSubsequence {

    // todo

    // 最长公共子序列
    //
    // 暴力递归
    // 设计 int f(char[] s1, char[] s2, int i1, int i2)
    // f函数实现，s1字符串从0出发到i1位置 s1[0...s1] 与 s2从0位置出发到i2 s2[0...s2]，这两个字符串的最长公共子序列
    // 四种可能性 （真是一点都想不到啊❕❕❕）
    // 1. s1从0位置出发到i1-1 与 s2从0位置出发到i2-1的最长公共子序列一样(最长公共子序列不包含最后一个)
    // 2. s1从0位置出发到i1-1 与 s2从0位置出发到i2的最长公共子序列一样
    // 3. s1从0位置出发到i1 与 s2从0位置出发到i2-1的最长公共子序列一样
    // 4. s1从0位置出发到i1 与 s2从0位置出发到i2的最长公共子序列一样，当s1[i1]==s2[i2]时，在第一种可能性的情况下加1
    // 但是该f函数涉及到下标 i1和i2 < 0的情况
    // 在设计dp表的时候会比较麻烦，需要预留一个-1的位置
    // 但是在预留-1的位置会可能发发生越界
    // 所以采用设计f2函数实现
    //
    // 设计 int f2(char[] s1, char[] s2, int len1, int len2)
    // f2函数实现，s1字符串前缀长度为len1 与 s2字符串前缀长度为len2，这两个字符串的最长公共子序列
    // len1=6 -> s1[0...5]
    // 这样边界条件就只有 len1==0 || len2==0

}
