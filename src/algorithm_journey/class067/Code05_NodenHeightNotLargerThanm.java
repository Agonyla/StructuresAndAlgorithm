package algorithm_journey.class067;

/**
 * @author: Agony
 * @create: 2024/9/3 21:26
 * @describe:
 * @link:
 */
public class Code05_NodenHeightNotLargerThanm {


    // todo

    // 节点数为n高度不大于m的二叉树个数

    // 暴力递归
    // 设计 int f(int n, int m) -> 返回节点数为n高度不大于m的二叉树个数
    // n -> 节点总数
    // m -> 高度
    // base case: n==0 -> return 1; 当节点数为0时候，总有一种结果
    // m==0 -> return 0; 当高度为0时，没有结果
    // 假设总共有5个节点，高度为3
    // 那么在头节点占有一个之后，就有如下5种情况
    // 左:0; 右:4，且高度<=2
    // 左:1,且高度<=2 ; 右:3，且高度<=2
    // 左:2,且高度<=2 ; 右:2，且高度<=2
    // 左:3,且高度<=2 ; 右:1，且高度<=2
    // 左:4,且高度<=2; 右:0，
    // 在每一种情况下的答案即为左右两种情况的乘积
    // 然后再所有情况结果相加
    // 注意⚠️：结果要通同余原理！！！
    //
    // 记忆化搜索
    // ...
    //
    // 动态规划
    //
    // 可变参数： n，m
    // 位置分析，来到(n, m)都依赖于(0~n-1, m-1)这些格子。  自己画图看一下❕❕❕
    // 填表顺序：从左往右，从上到下
    // ⚠️：一些特殊的位置，需要通过另外的for循环，或者在填表过程中另外执行
    //
    // 动态规划 + 空间压缩
    // 用一维代替二维dp
    // 之前题目的一维dp是横着的(记录的是每一列的数字)，然后按照行开始向下滚动更新
    // 该题设计的一维dp是竖着的(记录的是每一行的数字)，然后按照列开始向右滚动更新
    // dp更新的时候是从下往上更新，来到i位置，0~i-1位置表示是上一列还未更新的值


}













