package algorithm_journey.class067;

/**
 * @author: Agony
 * @create: 2024/9/3 20:58
 * @describe:
 * @link:
 */
public class Code04_LongestPalindromicSubsequence {

    // todo

    // 最长回文子序列
    //
    // 将字符串逆序，然后求连个字符串的最长公共子序列
    //
    // 新的尝试方法
    // 暴力递归
    // 设计 int f(char[] s, int l, int r) -> 从l到r这个区间最长回文子序列的长度
    // 情况分析
    // s[l]!=s[r]
    // 1. s[l+1...r-1]
    // 2. s[l...r-1]
    // 3. s[l+1...r]
    // 类似上一题，2，3两种情况结果肯定是>=1的
    // s[l]==s[r]
    // -> s[l+1...r-1] + 2
    //
    // 记忆化搜索
    // ...
    //
    // 动态规划
    // 显然可变参数只有l (0~s.length), r(0~s.length)
    // 且必然 l<=r -> 所以在二维dp表上只有右上角一半的区域
    // l==r这篇区域 dp[...] = 1
    // 从依赖位置分析，每一个格子依赖左边、左下、下边的位置
    // 所以填表顺序 -> 从左到右，从下到上
    //
    // 动态规划 + 空间压缩
    // 用一维数组代替二维dp表
    // 同样需要用变量来记录左下角的值
    // 类似于上一题


}
